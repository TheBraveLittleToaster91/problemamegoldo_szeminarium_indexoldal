<!DOCTYPE html>
<html lang="hu">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Room Allocation</title>
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header>
        <h1>Room Allocation</h1>
        <nav>
            <ul>
                <li><a href="../index.html">‚Üê Vissza a f≈ëoldalra</a></li>
            </ul>
        </nav>
    </header>
    <div class="kontener">
            
        <section class="feladat-leiras">
            <h2>Feladat le√≠r√°sa
                <a href="https://cses.fi/problemset/task/1164/" target="_blank" style="color: var(--szin-kiemeles); text-decoration: none; font-weight: bold;">
                    üîó
                </a>
            </h2>
            <p>Van egy nagy sz√°lloda, √©s <i>N</i> vend√©g √©rkezik hamarosan. Minden vend√©g egyetlen szob√°t szeretne.
                Ismered minden vend√©g √©rkez√©s√©nek √©s t√°voz√°s√°nak napj√°t.
                K√©t vend√©g csak √∫gy sz√°llhat meg ugyanabban a szob√°ban, ha az els≈ë vend√©g kor√°bban t√°vozik, mint ahogy a m√°sodik √©rkezik.
                Minimum h√°ny szoba sz√ºks√©ges az √∂sszes vend√©g elsz√°ll√°sol√°s√°hoz? √âs hogyan lehet a szob√°kat elosztani?</p>
        </section>
        <div class="grid-elrendezes">
            <section class="spec-blokk">
                <h3>Input</h3>
                <p>Az els≈ë bemeneti sor egy n eg√©sz sz√°mot tartalmaz: a vend√©gek sz√°m√°t.
                    <br>
                    Ezut√°n <i>N</i> sor k√∂vetkezik, amelyek mindegyike egy-egy vend√©g tart√≥zkod√°s√°t √≠rja le. Minden sorban k√©t eg√©sz sz√°m van, az √©rkez√©s √©s a t√°voz√°s napja: <i>A</i> √©s <i>B</i>.</p>
            </section>

            <section class="spec-blokk">
                <h3>Output</h3>
                <p>El≈ësz√∂r √≠rd ki a sz√ºks√©ges szob√°k minim√°lis sz√°m√°t: <i>k</i>.
                    <br>
                    Ezut√°n √≠rj ki egy sort, amely tartalmazza az egyes vend√©gek szobasz√°mait ugyanabban a sorrendben, ahogy az inputban voltak a vend√©gek. A szobasz√°mok 1, 2, ..., <i>k</i> sz√°moz√°s√∫ak. B√°rmelyik helyes sz√°moz√°st ki√≠rhatod.</p>
            </section>

            <section class="spec-blokk">
                <h3>Korl√°toz√°sok</h3>
                <p>
                    1 &le; <i>N</i> &le; 2 &sdot; 10<sup>5</sup>
                    <br>
                    1 &le; <i>A, B</i> &le; 10<sup>5</sup>
                    </p>
            </section>

            <section class="spec-blokk">
                <h3>P√©lda</h3>
                <pre>
Input:
3
1 2
2 4
4 4

Output:
2
1 2 1
                </pre>
            </section>
        </div>


        <section class="megoldas-kod">
            <h2>Megold√°s Python k√≥dja</h2>
            <div class="grid-elrendezes">
            <div class="kod-blokk">
                <pre>
<span class="sor-szam">1</span><span class="sor-tartalom"><span class="kulcsszo">import</span> heapq</span>
<span class="sor-szam">2</span><span class="sor-tartalom"><span class="kulcsszo">import</span> sys</span>
<span class="sor-szam">3</span><span class="sor-tartalom"></span>
<span class="sor-szam">4</span><span class="sor-tartalom">n = <span class="fuggveny">int</span>(sys.stdin.readline().<span class="fuggveny">strip</span>())</span>
<span class="sor-szam">5</span><span class="sor-tartalom"></span>
<span class="sor-szam">6</span><span class="sor-tartalom">customers = []</span>
<span class="sor-szam">7</span><span class="sor-tartalom"><span class="kulcsszo">for</span> i <span class="kulcsszo">in</span> <span class="fuggveny">range</span>(n):</span>
<span class="sor-szam">8</span><span class="sor-tartalom">    a, b = <span class="fuggveny">map</span>(<span class="fuggveny">int</span>, sys.stdin.readline().<span class="fuggveny">strip</span>().<span class="fuggveny">split</span>())</span>
<span class="sor-szam">9</span><span class="sor-tartalom">    customers.<span class="fuggveny">append</span>((a, b, i))</span>
<span class="sor-szam">10</span><span class="sor-tartalom"></span>
<span class="sor-szam">11</span><span class="sor-tartalom">customers.<span class="fuggveny">sort</span>(<span class="kulcsszo">key</span>=<span class="kulcsszo">lambda</span> x: x[<span class="szam">0</span>])</span>
<span class="sor-szam">12</span><span class="sor-tartalom"></span>
<span class="sor-szam">13</span><span class="sor-tartalom">room_allocations = [<span class="szam">0</span>] * n</span>
<span class="sor-szam">14</span><span class="sor-tartalom"></span>
<span class="sor-szam">15</span><span class="sor-tartalom">booked_rooms = [] </span>
<span class="sor-szam">16</span><span class="sor-tartalom"></span>
<span class="sor-szam">17</span><span class="sor-tartalom">available_room_ids = []</span>
<span class="sor-szam">18</span><span class="sor-tartalom"><span class="kulcsszo">for</span> i <span class="kulcsszo">in</span> <span class="fuggveny">range</span>(<span class="szam">1</span>, n + <span class="szam">1</span>):</span>
<span class="sor-szam">19</span><span class="sor-tartalom">    heapq.<span class="fuggveny">heappush</span>(available_room_ids, i)</span>
<span class="sor-szam">20</span><span class="sor-tartalom"></span>
<span class="sor-szam">21</span><span class="sor-tartalom">max_rooms_needed = <span class="szam">0</span></span>
<span class="sor-szam">22</span><span class="sor-tartalom"></span>
<span class="sor-szam">23</span><span class="sor-tartalom"><span class="kulcsszo">for</span> arrival, departure, original_index <span class="kulcsszo">in</span> customers:</span>
<span class="sor-szam">24</span><span class="sor-tartalom">    <span class="kulcsszo">if</span> booked_rooms <span class="kulcsszo">and</span> booked_rooms[<span class="szam">0</span>][<span class="szam">0</span>] <span class="szam"><</span> arrival:</span>
<span class="sor-szam">25</span><span class="sor-tartalom">        old_departure, room_id = heapq.<span class="fuggveny">heappop</span>(booked_rooms)</span>
<span class="sor-szam">26</span><span class="sor-tartalom">        room_allocations[original_index] = room_id</span>
<span class="sor-szam">27</span><span class="sor-tartalom">        heapq.<span class="fuggveny">heappush</span>(booked_rooms, (departure, room_id))</span>
<span class="sor-szam">28</span><span class="sor-tartalom">    <span class="kulcsszo">else</span>:</span>
<span class="sor-szam">29</span><span class="sor-tartalom">        room_id = heapq.<span class="fuggveny">heappop</span>(available_room_ids)</span>
<span class="sor-szam">30</span><span class="sor-tartalom">        max_rooms_needed = <span class="fuggveny">max</span>(max_rooms_needed, room_id)</span>
<span class="sor-szam">31</span><span class="sor-tartalom">        room_allocations[original_index] = room_id</span>
<span class="sor-szam">32</span><span class="sor-tartalom">        heapq.<span class="fuggveny">heappush</span>(booked_rooms, (departure, room_id))</span>
<span class="sor-szam">33</span><span class="sor-tartalom"></span>
<span class="sor-szam">34</span><span class="sor-tartalom"><span class="fuggveny">print</span>(max_rooms_needed)</span>
<span class="sor-szam">35</span><span class="sor-tartalom"><span class="fuggveny">print</span>(*(room_allocations))</span>
                </pre>
            </div>

            <div class="kod-magyarazo-blokk">
                <h3>El≈ëk√©sz√ºletek √©s rendez√©s (1-21. sorok)</h3>

                <ol>
                    <li><strong>Bemenet beolvas√°sa (4-9. sorok):</strong> <br>
                        Beolvassuk az √ºgyfelek √©rkez√©si √©s t√°voz√°si napjait. Fontos, hogy az √ºgyf√©l sorsz√°m√°t is t√°roljuk, mert a kimenetnek ezt a sorrendet kell k√∂vetnie. <code>(a, b, i)</code></li>
                    <li><strong>Rendez√©s (11. sor):</strong> Az √ºgyfeleket √©rkez√©si napjuk szerint n√∂vekv≈ë sorrendbe rendezz√ºk. Ez a moh√≥ strat√©gia alapja: mindig a legkor√°bban √©rkez≈ë √ºgyf√©llel foglalkozunk el≈ësz√∂r.</li>
                    <li><strong>Adatszerkezetek inicializ√°l√°sa (13-21. sorok):</strong>
                        <ul>
                            <li><code>room_allocations</code>: Lista az <i>N</i> db √ºgyf√©l szobasz√°mainak t√°rol√°s√°ra.</li>
                            <li><code>booked_rooms</code>: Egy min-heap (priorit√°si sor), ez t√°rolja a foglalt szob√°kat. A priorit√°st az adott szob√°ban tart√≥zkod√≥ √ºgyf√©l t√°voz√°si napja adja. Elemek form√°ja: <code>(b, i)</code></li>
                            <li><code>available_room_ids</code>: Egy min-heap, amely az 1-t≈ël <i>N</i>-ig terjed≈ë, legkisebb el√©rhet≈ë szobaazonos√≠t√≥kat t√°rolja.</li>
                            <li><code>max_rooms_needed</code>: Nyilv√°ntartja a maxim√°lisan felhaszn√°lt szobaazonos√≠t√≥t (a minim√°lis sz√ºks√©ges szobasz√°mot).</li>
                        </ul>
                    </li>
                </ol>

                <h3>√úgyfelek Elhelyez√©se (23-32. sorok)</h3>

                <p>V√©gigmegy√ºnk a rendezett √ºgyfeleken. Minden √ºgyf√©l √©rkez√©sekor k√©t eset lehets√©ges:</p>

                <ol start="4">
                    <li><strong>Szoba √∫jrahasznos√≠t√°sa (24-27. sorok):</strong>
                        <ul>
                            <li><strong>Felt√©tel (24. sor):</strong> A <code>booked_rooms</code> heap gy√∂ker√©ben l√©v≈ë t√°voz√°si nap <code>booked_rooms[0][0]</code> kisebb, mint az aktu√°lis √ºgyf√©l <code>arrival</code> √©rkez√©si napja, azaz a szoba felszabadult.</li>
                            <li><strong>Moh√≥ L√©p√©s (25-27. sorok):</strong> Kivessz√ºk a felszabadult szob√°t, majd ezt az azonos√≠t√≥t adjuk az aktu√°lis √ºgyf√©lnek. Ezut√°n az √ºgyf√©l t√°voz√°si napj√°val √©s a r√©gi azonos√≠t√≥val betessz√ºk a szob√°t a heapbe. A szoba sikeresen √∫jra lett hasznos√≠tva.</li>
                        </ul>
                    </li>
                    <li><strong>√öj szoba kijel√∂l√©se (28-32. sorok):</strong>
                        <ul>
                            <li><strong>Felt√©tel:</strong> A fenti felt√©tel nem teljes√ºl, azaz minden foglalt szoba √ºgyfele m√©g bent van az √©rkez√©skor.</li>
                            <li><strong>Moh√≥ L√©p√©s:</strong> √öj szob√°t kell kijel√∂lni. Kivessz√ºk a legkisebb sorsz√°m√∫ √∫j szob√°t.</li>
                            <li>Friss√≠tj√ºk a sz√ºks√©ges szobasz√°mot.</li>
                            <li>Az √∫j szob√°t r√∂gz√≠tj√ºk, √©s az √ºgyf√©l t√°voz√°si napj√°val betessz√ºk a <code>booked_rooms</code> heapbe.</li>
                        </ul>
                    </li>
                </ol>

                <h3>Kimenet (34-35. sorok)</h3>

                <ol start="6">
                    <li>Ki√≠rjuk a minim√°lis sz√ºks√©ges szobasz√°mot, majd a szobakioszt√°sokat az eredeti bemeneti sorrendben.</li>
                </ol>
            </div>
            </div>
        </section>

        <section class="magyarazat">
            <h2>Magyar√°zat</h2>

            <p>Ez a feladat egy klasszikus <strong>intervallum√ºtemez√©si probl√©ma</strong>, amelyben a c√©l a minim√°lis sz√°m√∫ er≈ëforr√°s (szoba) meghat√°roz√°sa √©s kioszt√°sa az adott id≈ëintervallumok (√ºgyf√©l tart√≥zkod√°sok) kezel√©s√©re. A megold√°s egy <strong>moh√≥ algoritmust</strong> haszn√°l, min-heap adatszerkezetekkel.</p>
 
            <h3>Mi√©rt a min-heap adatszerkezet?</h3>

            <p>A <strong>min-heap</strong> egy speci√°lis, <strong>fa-alap√∫ adatszerkezet</strong>, melynek alapvet≈ë tulajdons√°ga, hogy minden sz√ºl≈ë csom√≥pont √©rt√©ke kisebb vagy egyenl≈ë a gyermekei √©rt√©k√©n√©l.
                Ebb≈ël k√∂vetkezik a legfontosabb jellemz≈ë: <strong>a fa gy√∂kere tartalmazza a halmaz legkisebb elem√©t.</strong></p>

                <p>A min-heap a gyakorlatban gyakran egy t√∂mbben van megval√≥s√≠tva, ami lehet≈ëv√© teszi a hat√©kony t√°rol√°st √©s a gyors m≈±veleteket.</p>

                <h4>Mi√©rt ide√°lis a min-heap a feladathoz?</h4>

                <p>A min-heap haszn√°lata kulcsfontoss√°g√∫ a feladat hat√©kony moh√≥ megold√°s√°hoz, k√ºl√∂n√∂sen a foglalt szob√°k nyilv√°ntart√°s√°hoz. Az adatszerkezet optimaliz√°lja a k√©t legfontosabb m≈±veletet:</p>

                <ol>
                    <li><strong>Gyors hozz√°f√©r√©s a leghamarabbi t√°voz√°shoz</strong>

                    <p>A moh√≥ strat√©gi√°hoz mindig azt a szob√°t kell √∫jrahasznos√≠tani, amelyik a leghamarabb felszabadul. A <code>booked_rooms</code> heapben az elemek (t√°voz√°si_nap, szoba_azonos√≠t√≥) form√°ban vannak t√°rolva, a rendez√©si kulcs a t√°voz√°si nap.</p>

                    <ul>
                        <li>A heap tulajdons√°g√°nak k√∂sz√∂nhet≈ëen a leghamarabbi t√°voz√°si nap mindig a gy√∂k√©rben tal√°lhat√≥.</li>
                        <li>Az ellen≈ërz√©s, hogy van-e felszabad√≠that√≥ szoba √°lland√≥ id≈ë alatt, azaz <span class="ordo">O</span>(1) alatt v√©gezhet≈ë el.</li>
                    </ul>
                    <br>
                </li>
                    <li><strong>Hat√©kony felszabad√≠t√°s √©s √∫jrafoglal√°s</strong>

                        <ul>
                            <li><strong>Felszabad√≠t√°s:</strong> A felszabadul√≥ szoba kiv√©tele a gy√∂k√©rb≈ël: <code>heappop</code></li>
                            <li><strong>√öjrafoglal√°s:</strong> Az √∫j, k√©s≈ëbbi t√°voz√°si d√°tummal t√∂rt√©n≈ë visszat√©tel: <code>heappush</code></li>
                        </ul>

                        <p>Mindk√©t heap m≈±velet logaritmikus id≈ëben, azaz <span class="ordo">O</span>(log N) id≈ë alatt hajt√≥dik v√©gre, ahol <i>N</i> a foglalt szob√°k sz√°ma.</p>
                    </li>
                </ol>

                <h4>A K√©t Min-Heap Szerepe a K√≥dban</h4>

                <table border="1" cellpadding="5">
                    <thead>
                        <tr>
                            <th>Heap neve</th>
                            <th>T√°rolt adat</th>
                            <th>Rendez√©si kulcs</th>
                            <th>Funkci√≥</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>booked_rooms</code></td>
                            <td>(T√°voz√°si nap, Szoba ID)</td>
                            <td><strong>T√°voz√°si nap</strong></td>
                            <td>Moh√≥ d√∂nt√©s alapja: megtal√°lni a leghamarabb felszabadul√≥ szob√°t √∫jrahasznos√≠t√°s c√©lj√°b√≥l.</td>
                        </tr>
                        <tr>
                            <td><code>available_room_ids</code></td>
                            <td>Szoba ID-k (1, 2, 3...)</td>
                            <td><strong>Szoba ID</strong></td>
                            <td>Garant√°lja, hogy √∫j szoba ig√©nyl√©sekor mindig a legkisebb sorsz√°m√∫, m√©g nem haszn√°lt szoba ker√ºlj√∂n kioszt√°sra.</td>
                        </tr>
                    </tbody>
                </table>

            <h3>Id≈ëkomplexit√°s Elemz√©se</h3>

            <p>Az algoritmus id≈ëkomplexit√°sa
            <p style="text-align: center;"><strong><span class="ordo">O</span>(N log N)</strong>,</p>

            <ul>
                <li>A leglassabb m≈±velet az √ºgyfelek √©rkez√©si nap szerinti rendez√©se: <span class="ordo">O</span>(N log N).</li>
                <li>A f≈ë ciklus <i>N</i>-szer fut le, √©s minden iter√°ci√≥ban legfeljebb k√©t heap m≈±velet t√∂rt√©nik (<code>heappop</code> √©s <code>heappush</code>). Mivel a heap m√©rete legfeljebb <i>N</i> √©s minden m≈±velet <span class="ordo">O</span>(log N) id≈ët vesz ig√©nybe, ez√©rt a ciklus teljes id≈ëkomplexit√°sa <span class="ordo">O</span>(N log N).</li>
                <li>√ñsszess√©g√©ben az algoritmus id≈ëkomplexit√°sa <span class="ordo">O</span>(N log N), ami rendk√≠v√ºl hat√©kony.</li>
            </ul>
        </section>

        <section>
            <h2>Hasznos oldalak</h2>
            <ul>
                <li><a href="https://www.geeksforgeeks.org/dsa/introduction-to-min-heap-data-structure/" target="_blank">Intoduction to Min-Heap</a></li>
                <li><a href="https://en.wikipedia.org/wiki/Min-max_heap" target="_blank">Min-max heap</a></li>
            </ul>
        </section>

    </div>

    <footer>
        <p>&copy; P√≥sfai L≈ërinc, 2025</p>
    </footer>

</body>
</html>
